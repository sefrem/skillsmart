
1. Если исходить из данного определения зависимости
    > Свойство P, определяемое в некоторой вычислительной модели, зависит от компонента 
   > A тогда и только тогда, когда A -- фактическая причина P (относительно пространства допустимых 
   > изменений A)
     
    то можно сделат вывод, что то, что обычно понимается под зависимостью от фреймворка или бибилотеки на самом деле
    зависимостью не являетс. Неважно, какой конкретно планировщик вызывает задачу, или какой конкретно 
    фреймворк собирает HTML в готовый темплейт для отображения на странице - они не являются фактической
    причиной задачи или шаблона. Они - просто средство реализации бизнес-логики. В крайнем случае они могут являться
    частью зависимости, если они каким-то образом влияют на реализуемую логику (например, если они накладывают какие-то
    ограничения по производительности).

    Как относительно похожий пример могу привести, что у нас в компании сейчас бэкендеры для новых сервисов
    переходят с Java на Go, потому что Spring требует минимум 200мб оперативной памяти для самого маленького сервиса,
    что может создавать большую нагрузку, если сервисов много. У Go такой проблемы нет.


2. Проблема, описанная в п.2 - стандартная проблема взаимодействия фронтенда и бэкенда,
    обычно решается выделением "интерфейса" - спецификации, описывающей формат данных, от которой уже
    и зависит и A и B.


3. Проблема зависимости зависимости обычно решается или строгим линтером, который, например,
    может запрещать импорты из опеределеных модулей, или на код-ревью, когда другие разработчики
    могут указать на модификацию глобальной переменной, например. Кажется, что работу с такого рода зависимостями
    довольно сложно формализовать, очень разноплановыми они могут быть.


4. Обычно такого рода зависимости решаются добавлением error boundaries на уровне каждого модуля,
    чтобы ошибки не могли полностью положить систему, и в каком-то виде, пусть и неполноценном, она была бы доступна.
    Но тут возникает сложность с тем, что часто довольно сложно предусмотреть все варианты, когда такие ошибки монут возникнуть,
    и обычно проблемные места выясняются уже после того, когда ошибка возникла и система или ее часть упали.


5. Данная проблема - следствие избыточности ключевых точек бизнес-логики. Каждый сервис - часть зависимости. Они не равнозначны
    друг другу, так как могут работать немного по-разному. 


6. В нашем проекте на Angular активное используется DI, но из-за строгой типизации Typescript
    проблем с этим нет - все модули тппизированы.


7. Это - один из самых сложных и неприятных видов зависимостей, потому что если мы, например, имеем дело с 
    микросервисной архитектурой, то там выстраиваются цепочки зависимостей сервисов, и получается, что весь проект взаимосвязан
    по нескольку раз. Возможно, тут должны помогать паттерны проектирования, но я не занимался распутыванием таких зависимостей.


8. Кажется, что это не совсем зависимость, а просто неправильная/некорректная реализация бизнес-логики. Если я в array.filter
    передам функцию, которая будет отфильтровывать не правдивые, а ложные значения - это не вина метода filter, и не проблема 
    зависимости от него, это скорее проблема зависимости от плохого разработчика. Она разрешается только увольнением. У нас на проекте
    есть некоторое количество контракторов другой компании, о совсем плохих из них мы сигнализируем менеджменту, что с проекта их нужно убрать.


9. Не имел дела с такого рода вариантом зависимостей.