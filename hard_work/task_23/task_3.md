
1. Зависимость фреймворка.
    Думаю, классический планировщик зависит от задачи в том плане, что у нас
    скорее всего есть какой-то интерфейс задачи, с которым он обучен работать (вызывать, логировать и т.д.).
    Все задачи реализуют этот интерфейс.
    Если А вызывает В, то А зависит от В. Обычно такого рода зависимости (например, от библиотеки) решаются добавлением между 
    А и В какого-то интерфейса. Если мы меняем библиотеку В, нужно научить промежуточный интерфейс с ней работать. Кажется,
    я только что описал паттерн Адаптер. 
    Делал что-то подобное недавно, когда сделал отдельный сервис для обмена сообщениями между нашей системой и внешней бибилиотекой.
    Сначала я обращался к методам библиотеки напрямую там, где производилесь отправка сообщений. Потом часть логики нужно было вынести
    за пределы нашей системы, а для того, что осталось внутри, я сделал сервис обмена сообщениями, который просто умеет работать с сообщениями.
    Естественно, все равно А (наша система) зависит от В (внешняя бибилотека), просто более понятна точка зависимости. Если В изменит формат сообщений,
    который она принимает, мне придется внести изменения в А.

2. Зависимость расшаренного формата
    Когда две стороны (клиент и сервер) работают с одним и теми же данными (например, сообщения, передаваемые по Апи),
    то кажется, что зависимость идет в сторону отправки сообщения. Т.е. "больше" зависит та сторона, которая отправляет сообщение.
    В случае, если например, клиент начне в какой-то момент слать сообщения в другом формате и сервер не сможет их 
    обрабатывать, правки будут делаться на клиенте, а не на сервере. Это же верно и для обратной ситуации.
    Обычно такого рода зависимости решаются на этапе разработки (например, Апи. Согласовывается контракт, формат сообщений,
    далее его обе стороны реализуют. Любые изменения в нем также должны согласовываться обеими сторонами (в идеале, если это внутреннее Апи).
    В случае с внешним Апи остается надеяться на порядочность третьей стороны и внимательно смотреть ченджлоги сторонних библиотек на предмет
    необратимых изменений.
    В нашей системе есть сервисы, которые работают со сторонними интеграциями (salesforce, zendesk и т.д.). Недавно мы делали большой
    рефакторинг взаимодействия между этими сервисами и нашим бэкендом. Основное, на что был направлен рефакторинг - уменьшение количества
    типов сообщений и уменьшение размера самого сообщения. Это потребовало взаимодействия и согласования фронтенда и бэкенда.

3. Зависимость зависимости.
    Очень плохой вид зависимости - скрытая, неочевидная зависимость.
    Такие зависимости обычно устраняются рефакторингом частей программы. В какой-то степени их можно поймать при помощи 
    тестов.

4. Зависимость краша.
    В предыдущем занятии я приводил пример такой зависимости - наша система зависела от сервиса для управления переводами, 
    и когда его кэш инвалидировался, он упал под нагрузкой, что привело к недоступности всей системы.
    Как в данном конкретном случае решили проблему на будущее я не знаю, этим не занимался, возможно, просто добавили еще несколько инстансов сервиса.
    Но вообще подобного рода неявные зависимости между частями системы можно выявить стресс тестами.

5. Зависимость перебрасывания.
    В данном случае получается избыточность - мы вместо одной зависимости добавляем еще несколько, чтобы обеспечить отказоустойчивость
    нашей системы. Но все это остается зависимостями.
    Я делал подобное для важных частей бизнес-логики. В случае получения ошибки от Апи, делал вызовы других резервных эндпоинтов.
    Это было осознанное решение по усилению надежности сервиса.

6. Зависимость инверсии.
    Не совсем понял, но кажется тут в описании немного спутаны DI (Dependency Injection) и DIP (Dependency Inversion Principle). 
    Ведь при инверсии зависимостей зависимости просто переставляются таким образом, что высокоуровневые модули перестают зависеть от низкоуровневых,
    а и те и другие зависят от общего интерфейса. В таком случае мы не терям никаких проверок тайп чекинга.
    Но и при Dependency Injection проверки типов никуда не деваются, ведь ты заранее в модуле описываешь, какие модули тебе в нем будут
    нужны. По крайней мере у нас в проекте так устроено.

7. Зависимость зацикливания
    У нас в проекте линтер предупреждает про циклические импорты, что решает эту проблему.

8. Зависимость высшего порядка
    Получается, что да - библиотеки зависят от вызывающего их кода, если они используют что-то (например, функцию сравнения или
    хеширования), что вызывающий код может переопределить, "сломав" таким образом ожидаемое поведение библиотеки.

9. Зависимость большинства
    Такого опыта у меня не было. 
    Но система все равно зависит от каждой реализации, потому что если изменить все 5, изменится и поведение системы.