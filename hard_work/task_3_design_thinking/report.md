Касательно рабочего кода - у меня сейчас нет таких задач, где нужно писать много кода, в основном это багфиксы или задача на исследование интеграции со сторонней црм. 

Поэтому я взял один из проектов, который я делал на буткемпе пару лет назад - карточную игру blackjack с мультиплеером по вебсокетам.
Я решил добавить к ней новую фичу - возможность “разбить пары”. Это один из возможных ходов в блэкджеке, когда игроку сдаются 2 карты одинакового номинала - разбить их на 2 руки и играть каждой независимо.

После прочтения материалов из Сильных идей обратил внимание, что тесты, написанные до этого, довольно близко следуют реализации логики (2 уровень) и при изменении имплементацию придется править и тесты.
Поэтому после прочтения постарался писать тесты, которые бы работали на 3 уровне, т.е. описывали бы бизнес-логику, а не реализацию.
[Пример](https://github.com/sefrem/skillsmart/blob/master/hard_work/task_3_design_thinking/tests.ts) тестов.

В тесте ДО

Проверяю, что при раздаче карт для 2 игроков 2 раза вызывается метод, определяющий, можно ли делить карты. Тест повторяет реализацию и легко может сломаться.

В тесте ПОСЛЕ

Главное отличие здесь, что после инициализации новой игры я смотрю на сообщение, отправленное с бэкенда в вебсокетах
и проверяю, что в состоянии игроков ключи, показывающие можно или нельзя делить пары, находятся в верных состояниях.
Этот тест более устойчив к изменениям, потому что отвязан от конкретной реализации и просто проверяет, что у объектов
игроков в начале игры правильно рассчитано состояние.

Однако во втором тесте тоже проглядываются детали из 2 уровня - например, пришлось замокать метод, достающий верхнюю карту из колоды, чтобы он отдал нужные. Также тест знает, что сообщение с состоянием пойдет по вебсокетам и тоже может сломаться при изменении формата взаимодействия между фронтом и беком.
Возможно, это я далеко шагнул и правильнее было бы доставать объекты игроков из базы и проверять, но в этом проекте нет базы, все просто хранится в памяти сервера.

Кажется, что юнит-тесты могут чаще всего быть подвержены такой проблеме - быть написанными на 2 уровне вместо 3-го. Но с другой стороны кажется, будто они и не могут быть написаны на 3 уровне, потому что тестируют правильность работы конкретного метода. На 3 уровне могут и должны быть написаны уже интеграционные тесты, которые проверяют кусочек бизнес-логики.