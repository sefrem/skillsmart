**1. Это не баг.**


1. Делаю интеграцию с salesforce. В их апи есть метод, который можно заимплементировать, если нужно возвращать динамическую ссылку
на запись звонка. В конфиге включаешь отдельным ключом, что этот метод у тебя заимплементирован. Однако, salesforce его не вызывает,
если перед этим не будет вызван с бэкенда (нашего) апи метод обновления записи о звонке в salesforce. Метод может ничего не обновлять, 
важен сам факт того, что он был вызван. Тогда salesforce начинает вызывать имплементированный на фронтенде метод динамического получения
ссылки на запись. В документации ничего про это нет, все установлено опытным путем. Кажется, что это не баг.

2. Делал задачу - добавить выбор типа завершаемого звонка для разных типов звонков, которые будут использоваться системой по умолчанию.
При поиске по типам звонков я отсеял те, которые помечены клиентом как скрытые. От клиента пришло обращение, что он хочет, чтобы
эти типы показывались и были доступны для выбора, потому что он использует эту возможность скрытия, чтобы настраивать видимость данных для разных
типов пользователей. Соответственно, моя изначальная имплементация не является багом с точки зрения системы, но является багом с точки зрения клиента.

**2. Это не баг (а что-то другое)**

1. У нас в проекте долго была проблема, которая рождала множество багов. В проекте есть веб-сокет соединение. Изначально
система писалась с расчетом на то, что сообщения будут приходить в определенном порядке. Т.е. синхронно, асинхронность в расчет не 
была взята. Это не было сделано специально, просто так получилось. И это работало, пока не был переписан бэкендовый сервис, который
отправляет сообщения. Он перестал гарантировать порядок сообщений. Из-за этого началось большое количество проблем на фронте, потому что
он не был готов к этому вообще. Получается, что следствием этого было возникновение багов, а причина багом не была. 


**3. Это сбивает людей с толку**


1. Мне кажется, у нас весь проект такой. Т.е. один большой артефакт. Я уже писал про объект интеракции, который создается и
мутируется различными методами в ходе звонка. В нем больше половины вроде бы не используемых нигде данных. На его основе производится
много различных действий, при это понять что конкретно он будет из себя представлять по ходу интеракции можно только на первом уровне
работы программы - в рантайме, обожившись логированием. Естественно, его поведение нигде не описано. То же самое можно сказать и про
dataBridge - god-object при работе с какой-либо интеграцией (salesforce, zendesk, etc). Он также строится на ходу и также понять, что он из
себя представляет можно только в рантайме.
2. Наверное сюда можно отнести классический "баг" javascript - typeof null -> "object"


**4. Это хрупкость**


1. Был у нас баг, который положил всю систему многим клиентам. Для переводов у нас используется weblate - опен-сорсная библиотека для хранения и 
версионирования переводов. Он жил в одном инстансе. Он обслуживал все запросы от всех клиентов, потому что все переводы им у себя кэшировались.
В какой-то момент, точно не помню из-за чего, этот кэш инвалидировался и все запросы стали идти на сервис. Под нагрузкой он лег, возвращал ошибки,
как следствие система не грузилась. Был большой инцидент, много клиентов было затронуто.

2. Еще одно следствие проблемы, о которой я писал выше в п.2 (про сообщения из веб-сокетов). Теперь кроме разного порядка сообщений одной интеракции
мы также иногда можем получить сообщения от нескольких разных интеракций. Это приводит к тому, что весь объект интеракции перетирается, и начинает
создаваться новый. Это ведет к различным вариантам некорректного состояния интерфейса у агента. 


**5. Не соответствует требованиям OSHA (Администрация по охране и гигиене труда США)**

1. Настолько плохого личного опыта не было, но читал байку в инетрнете о том, как программист пришел на проект, где использовался
свой язык на основе json (JSON-based Domain Specific Language), и написав в нем несколько комментов, поломал что-то в базе у клиента, 
потому что этот самописный движок не умел работать с комментарями, и исполнял их как обычный код. Все остальные разработчики про это знали, и так не делали.