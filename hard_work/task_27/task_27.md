
1.

1. Я разрабатывал интеграцию с Salesforce. У класса, который нужно реализовать для корректной работы интеграции, есть метод,
    которым Salesforce получает ссылку на запись разговора. В конфигурации, которую я передаю в Salesforce, есть флаг с именем этого
    метода. Я полагал, что стоит только передать этот флаг как true, и Salesforce начнет вызывать этот метод пи загрузке информации о звонке. Туда
    я собирался передавать динамически сгенерированный url. Оказалось, что этого недостаточно, и по какой-то причине нужно сделать апи вызов на обновление
    информации о звонке в Salesforce, пусть даже и пустой, и только после этого он начнет вызывать метод для получения url.
    В данном случае подходят оба варианта - это поведение не описано в документации (и вообще выглядит как баг), и я ошибочно предположил,
    исходя из наличия метода и флага, что этого будет достаточно, чтобы Salesforce его вызывал.


2. Пример, где я скорее выступаю второй стороной. У нас есть набор апи, в основном касающихся действий во время звонка - hold/unhold, mute/unmute,
    record on/record off и т.д. Какое-то время назад мы переходили с "синхронных" вариантов этих апи на "асинхронные". Новый вариант заключается в том,
    что http-запрос всегда возвращает 200, а реальный ответ приходит в сообщении с темой 'httpApiResponse' в веб-сокете. Переход на фронте в основном
    делал я. Недавно ко мне пришли 2 коллег бэкендеров (во время изменений их еще не было на проекте) с расследованием бага. На одном из этапов
    на фронте появляется уведомление об ошибке, и они не могли понять откуда оно там, ведь все апи-запросы отрабатывают успешно. Но в логи не пишутся (по
    крайней мере в те логи, что они смотрели) сообщения из веб-сокетов. По сообщениям можно было понять, что на самом деле запрос возвращается с ошибкой, оттуда
    и уведомление.
    Я понял, что логика этих апи у нас или совсем не описана, или описана где-то в глубине документации, куда еще не так-то просто добраться. Я точно ничего
    не писал. Соответственно, мои коллеги ошибочно предположили как будет работать сторонний код, исходя из того, что они видят. Моя ошибка, что на этапе
    работы над переходм на новой апи я не поднял вопрос или сам не описал эту логику в документации, которой пользуются разработчики.


3. На предыдущей работе была такая особенность, что у пользователей в системе было 2 id - id, видный пользователю (алиас) и реальный id пользователя
    в базе. Алиас придумали для того, потому что некоторые пользователи хотели купить себе "красивый" id. Но это привело к тому, что иногда для каких-то
    апи разные команды называли один и тот же id разными именами (т.е. это или нормальный id или alias). Почему-то конкретно в моей команде то, что мы называли
    алиасом, было обычным id. Узнал я про это, когда безуспешно пытался получить информацию от сервиса другой команды по этому id. Впоследствии я даже делал апи для других
    команд, чтобы вернуть им алиас пользователя.
    В данном случае я ошибочно предположил, что id - это уникальный индентификатор пользователя, и он всегда присутствует в единственном экземпляре. Для id была
    документация, но заранее я ее не искал.


2. 


   До
               
      private callLogFieldValue(field: keyof typeof CallLogLabels): string | null {
            if (this.fieldToValueMap[field]) {
              return String(this.fieldToValueMap[field](this.dataBridge));
            } else {
              this.errors.push('callLogFieldValue does not map field ' + field + ' to any value.');
              return null;
            }
        }

   После

       private callLogFieldValue(field: keyof typeof CallLogLabels): string {
           if (this.fieldToValueMap[field]) {
           return String(this.fieldToValueMap[field](this.dataBridge));
           } else {
           this.errors.push('callLogFieldValue does not map field ' + field + ' to any value.');
           return '';
           }
       }

Теперь результат всегда строка, не нужно делать проверки на `null`


