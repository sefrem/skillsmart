
//2. Придумайте случай, когда вам потребовалось расширить некоторый класс дополнительной фичей,
// но он уже закрыт для изменений, а создание его нового наследника под небольшое расширение
// смотрится как стрельба из пушки по воробьям. Подумайте, как реализовать паттерн со словарём: например,
// требуется добавить в класс A новое поле, и доступ к его значению организовывается через словарь,
// который в качестве ключа хранит некоторый хэш конкретного объекта.
//
// Как вы считаете, получается упрощение, или усложнение модели данных в проекте?

 class ClosedClass {}

class ActionClass {
    propertiesMap = new Map();
}
const actionClass = new ActionClass();

function additionalActionForClosedClass() {}

actionClass.propertiesMap.set(ClosedClass, additionalActionForClosedClass);

// Думаю, что с первого взгляда это может показаться ненужным усложнением, и болек привычно и ожидаемо сделать
// класс-наследник ClosedClass для нужных методов.
// Но если выработать внутрикомандную договоренность не расширяться классы, а складыать методы в словарь, можно
// не допустить роста количества бессмысленых с точки зрения программы цепочек наследования. С этой точки зрения получится упрощение.
// Но теперь в этом словаре будут скапливаться дополнительные методы для разных классов без четкого разделения. Здесь потенциальная
// точка усложнения. Наверное при наличии тут нескольких методов для одного и того же класса, можно все-таки подумать о его
// расширении через наследование. В таком случае получится соблюсти баланс и использовать словарь только для единичных случаев.