
Пример 1.
Предположим, мы разрабатываем юнитов для компьютерной игры. У нас есть типы "базовый юнит", "копьеносец", "лучник", "конный юнит".
Каждый из них может иметь модификации вида "базовый бронированный юнит", "базовый быстрый юнит".  
Первоначально может показаться хоршей идеей наследовать всех юнитов от базового (отношения "является"). Однако более подходящим будет
решение с отношениями "содержит", т.е. мы создаем абстрактный класс юнита, от которого мы наследуем все остальные типы юнитов. 
Отличия между ними кодируются при помощи полиморфных полей класса. Например, поле "оружие", что и будет основным отличием между юнитами.
Также может быть поле "средство передвижения", потому что у нас могут быть не только конные юниты, но и, например, юниты на колеснице.
Таким образом, несложно будет создавать и новые типы юнитов, например конный лучник. 

Пример 2.
Предположим, мы разрабатываем программу, которой будут ползоваться архитекторы, и в ней есть разные типы домов. Например, частный дом, таунхаус,
многоквартирный дом, дом из кирпича, блока, сруба и т.д. Можно попытаться организовать их в иерархию "является". К примеру, наследовать частный дом из
кирпича от частного дома. А таунхаус из кирпича - от частного дома из кирпича. Но более логично наследовать все дома от базового интерфейса дома, а 
различия - материал, этажность и т.д. сделать полиморфными полями класса (отношения является).